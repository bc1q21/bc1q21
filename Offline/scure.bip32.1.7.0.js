/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/@scure/bip32@1.7.0/lib/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HDKey=exports.HARDENED_OFFSET=void 0;
/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const modular_1=require("@noble/curves/abstract/modular"),secp256k1_1=require("@noble/curves/secp256k1"),hmac_1=require("@noble/hashes/hmac"),legacy_1=require("@noble/hashes/legacy"),sha2_1=require("@noble/hashes/sha2"),utils_1=require("@noble/hashes/utils"),base_1=require("@scure/base"),Point=secp256k1_1.secp256k1.ProjectivePoint,base58check=(0,base_1.createBase58check)(sha2_1.sha256);function bytesToNumber(e){(0,utils_1.abytes)(e);const t=0===e.length?"0":(0,utils_1.bytesToHex)(e);return BigInt("0x"+t)}function numberToBytes(e){if("bigint"!=typeof e)throw new Error("bigint expected");return(0,utils_1.hexToBytes)(e.toString(16).padStart(64,"0"))}const MASTER_SECRET=(0,utils_1.utf8ToBytes)("Bitcoin seed"),BITCOIN_VERSIONS={private:76066276,public:76067358};exports.HARDENED_OFFSET=2147483648;const hash160=e=>(0,legacy_1.ripemd160)((0,sha2_1.sha256)(e)),fromU32=e=>(0,utils_1.createView)(e).getUint32(0,!1),toU32=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error("invalid number, should be from 0 to 2**32-1, got "+e);const t=new Uint8Array(4);return(0,utils_1.createView)(t).setUint32(0,e,!1),t};class HDKey{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return fromU32(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const e=this.privateKey;if(!e)throw new Error("No private key");return base58check.encode(this.serialize(this.versions.private,(0,utils_1.concatBytes)(new Uint8Array([0]),e)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return base58check.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(e,t=BITCOIN_VERSIONS){if((0,utils_1.abytes)(e),8*e.length<128||8*e.length>512)throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got "+e.length);const i=(0,hmac_1.hmac)(sha2_1.sha512,MASTER_SECRET,e);return new HDKey({versions:t,chainCode:i.slice(32),privateKey:i.slice(0,32)})}static fromExtendedKey(e,t=BITCOIN_VERSIONS){const i=base58check.decode(e),r=(0,utils_1.createView)(i),s=r.getUint32(0,!1),n={versions:t,depth:i[4],parentFingerprint:r.getUint32(5,!1),index:r.getUint32(9,!1),chainCode:i.slice(13,45)},o=i.slice(45),h=0===o[0];if(s!==t[h?"private":"public"])throw new Error("Version mismatch");return new HDKey(h?{...n,privateKey:o.slice(1)}:{...n,publicKey:o})}static fromJSON(e){return HDKey.fromExtendedKey(e.xpriv)}constructor(e){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!e||"object"!=typeof e)throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||BITCOIN_VERSIONS,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!secp256k1_1.secp256k1.utils.isValidPrivateKey(e.privateKey))throw new Error("Invalid private key");this.privKey="bigint"==typeof e.privateKey?e.privateKey:bytesToNumber(e.privateKey),this.privKeyBytes=numberToBytes(this.privKey),this.pubKey=secp256k1_1.secp256k1.getPublicKey(e.privateKey,!0)}else{if(!e.publicKey)throw new Error("HDKey: no public or private key provided");this.pubKey=Point.fromHex(e.publicKey).toRawBytes(!0)}this.pubHash=hash160(this.pubKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const t=e.replace(/^[mM]'?\//,"").split("/");let i=this;for(const e of t){const t=/^(\d+)('?)$/.exec(e),r=t&&t[1];if(!t||3!==t.length||"string"!=typeof r)throw new Error("invalid child index: "+e);let s=+r;if(!Number.isSafeInteger(s)||s>=exports.HARDENED_OFFSET)throw new Error("Invalid index");"'"===t[2]&&(s+=exports.HARDENED_OFFSET),i=i.deriveChild(s)}return i}deriveChild(e){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let t=toU32(e);if(e>=exports.HARDENED_OFFSET){const e=this.privateKey;if(!e)throw new Error("Could not derive hardened child key");t=(0,utils_1.concatBytes)(new Uint8Array([0]),e,t)}else t=(0,utils_1.concatBytes)(this.pubKey,t);const i=(0,hmac_1.hmac)(sha2_1.sha512,this.chainCode,t),r=bytesToNumber(i.slice(0,32)),s=i.slice(32);if(!secp256k1_1.secp256k1.utils.isValidPrivateKey(r))throw new Error("Tweak bigger than curve order");const n={versions:this.versions,chainCode:s,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e};try{if(this.privateKey){const e=(0,modular_1.mod)(this.privKey+r,secp256k1_1.secp256k1.CURVE.n);if(!secp256k1_1.secp256k1.utils.isValidPrivateKey(e))throw new Error("The tweak was out of range or the resulted private key is invalid");n.privateKey=e}else{const e=Point.fromHex(this.pubKey).add(Point.fromPrivateKey(r));if(e.equals(Point.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");n.publicKey=e.toRawBytes(!0)}return new HDKey(n)}catch(t){return this.deriveChild(e+1)}}sign(e){if(!this.privateKey)throw new Error("No privateKey set!");return(0,utils_1.abytes)(e,32),secp256k1_1.secp256k1.sign(e,this.privKey).toCompactRawBytes()}verify(e,t){if((0,utils_1.abytes)(e,32),(0,utils_1.abytes)(t,64),!this.publicKey)throw new Error("No publicKey set!");let i;try{i=secp256k1_1.secp256k1.Signature.fromCompact(t)}catch(e){return!1}return secp256k1_1.secp256k1.verify(i,e,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,t){if(!this.chainCode)throw new Error("No chainCode set");return(0,utils_1.abytes)(t,33),(0,utils_1.concatBytes)(toU32(e),new Uint8Array([this.depth]),toU32(this.parentFingerprint),toU32(this.index),this.chainCode,t)}}exports.HDKey=HDKey;
//# sourceMappingURL=/sm/18f611e708360b6ab116ced20104897dd30d5014daf3f98d787ff0cdb1eaa5b3.map